<?xml version="1.0" encoding="UTF-8"?>
<testsuite name="plc.project.ParserExpressionTests" tests="18" skipped="0" failures="1" errors="0" timestamp="2025-09-28T03:56:09.214Z" hostname="DESKTOP-QJV9TMV" time="0.177">
  <properties/>
  <testcase name="[1] Variable, [IDENTIFIER=name@0], Ast.Expression.Access{receiver=Optional.empty, name='name'}" classname="plc.project.ParserExpressionTests" time="0.05"/>
  <testcase name="[2] Field Access, [IDENTIFIER=obj@0, OPERATOR=.@3, IDENTIFIER=field@4], Ast.Expression.Access{receiver=Optional[Ast.Expression.Access{receiver=Optional.empty, name='obj'}], name='field'}" classname="plc.project.ParserExpressionTests" time="0.002"/>
  <testcase name="[1] Grouped Variable, [OPERATOR=(@0, IDENTIFIER=expr@1, OPERATOR=)@5], Ast.Expression.Group{expression=Ast.Expression.Access{receiver=Optional.empty, name='expr'}}" classname="plc.project.ParserExpressionTests" time="0.003"/>
  <testcase name="[2] Grouped Binary, [OPERATOR=(@0, IDENTIFIER=expr1@1, OPERATOR=+@7, IDENTIFIER=expr2@9, OPERATOR=)@14], Ast.Expression.Group{expression=Ast.Expression.Binary{operator='+', left=Ast.Expression.Access{receiver=Optional.empty, name='expr1'}, right=Ast.Expression.Access{receiver=Optional.empty, name='expr2'}}}" classname="plc.project.ParserExpressionTests" time="0.001"/>
  <testcase name="[1] Boolean Literal, [IDENTIFIER=TRUE@0], Ast.Expression.Literal{literal=true}" classname="plc.project.ParserExpressionTests" time="0.002"/>
  <testcase name="[2] Integer Literal, [INTEGER=1@0], Ast.Expression.Literal{literal=1}" classname="plc.project.ParserExpressionTests" time="0.022">
    <failure message="org.opentest4j.AssertionFailedError: expected: plc.project.Ast$Expression$Literal@36cda2c2&lt;Ast.Expression.Literal{literal=1}&gt; but was: plc.project.Ast$Expression$Literal@3697186&lt;Ast.Expression.Literal{literal=1}&gt;" type="org.opentest4j.AssertionFailedError">org.opentest4j.AssertionFailedError: expected: plc.project.Ast$Expression$Literal@36cda2c2&lt;Ast.Expression.Literal{literal=1}&gt; but was: plc.project.Ast$Expression$Literal@3697186&lt;Ast.Expression.Literal{literal=1}&gt;
	at app//org.junit.jupiter.api.AssertionFailureBuilder.build(AssertionFailureBuilder.java:151)
	at app//org.junit.jupiter.api.AssertionFailureBuilder.buildAndThrow(AssertionFailureBuilder.java:132)
	at app//org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:197)
	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:182)
	at app//org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:177)
	at app//org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:1141)
	at app//plc.project.ParserExpressionTests.test(ParserExpressionTests.java:268)
	at app//plc.project.ParserExpressionTests.testLiteralExpression(ParserExpressionTests.java:71)
	at java.base@17.0.13/java.lang.reflect.Method.invoke(Method.java:568)
	at java.base@17.0.13/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:179)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:183)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:992)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:762)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:992)
	at java.base@17.0.13/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base@17.0.13/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base@17.0.13/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base@17.0.13/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base@17.0.13/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base@17.0.13/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)
	at java.base@17.0.13/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625)
	at java.base@17.0.13/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base@17.0.13/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base@17.0.13/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base@17.0.13/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base@17.0.13/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base@17.0.13/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base@17.0.13/java.util.stream.ReferencePipeline$7$1.accept(ReferencePipeline.java:276)
	at java.base@17.0.13/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1625)
	at java.base@17.0.13/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)
	at java.base@17.0.13/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)
	at java.base@17.0.13/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:150)
	at java.base@17.0.13/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:173)
	at java.base@17.0.13/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base@17.0.13/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)
	at java.base@17.0.13/java.util.ArrayList.forEach(ArrayList.java:1511)
	at java.base@17.0.13/java.util.ArrayList.forEach(ArrayList.java:1511)
</failure>
  </testcase>
  <testcase name="[3] Decimal Literal, [DECIMAL=2.0@0], Ast.Expression.Literal{literal=2.0}" classname="plc.project.ParserExpressionTests" time="0.002"/>
  <testcase name="[4] Character Literal, [CHARACTER='c'@0], Ast.Expression.Literal{literal=c}" classname="plc.project.ParserExpressionTests" time="0.0"/>
  <testcase name="[5] String Literal, [STRING=&quot;string&quot;@0], Ast.Expression.Literal{literal=string}" classname="plc.project.ParserExpressionTests" time="0.0"/>
  <testcase name="[6] Escape Character, [STRING=&quot;Hello,\nWorld!&quot;@0], Ast.Expression.Literal{literal=Hello,&#10;World!}" classname="plc.project.ParserExpressionTests" time="0.0"/>
  <testcase name="[1] Zero Arguments, [IDENTIFIER=name@0, OPERATOR=(@4, OPERATOR=)@5], Ast.Expression.Function{receiver=Optional.empty, name='name', arguments=[]}" classname="plc.project.ParserExpressionTests" time="0.003"/>
  <testcase name="[2] Multiple Arguments, [IDENTIFIER=name@0, OPERATOR=(@4, IDENTIFIER=expr1@5, OPERATOR=,@10, IDENTIFIER=expr2@12, OPERATOR=,@17, IDENTIFIER=expr3@19, OPERATOR=)@24], Ast.Expression.Function{receiver=Optional.empty, name='name', arguments=[Ast.Expression.Access{receiver=Optional.empty, name='expr1'}, Ast.Expression.Access{receiver=Optional.empty, name='expr2'}, Ast.Expression.Access{receiver=Optional.empty, name='expr3'}]}" classname="plc.project.ParserExpressionTests" time="0.001"/>
  <testcase name="[1] Assignment, [IDENTIFIER=name@0, OPERATOR==@5, IDENTIFIER=value@7, OPERATOR=;@12], Ast.Statement.Assignment{receiver=Ast.Expression.Access{receiver=Optional.empty, name='name'}, value=Ast.Expression.Access{receiver=Optional.empty, name='value'}}" classname="plc.project.ParserExpressionTests" time="0.0"/>
  <testcase name="[1] Binary And, [IDENTIFIER=expr1@0, OPERATOR=&amp;&amp;@6, IDENTIFIER=expr2@10], Ast.Expression.Binary{operator='&amp;&amp;', left=Ast.Expression.Access{receiver=Optional.empty, name='expr1'}, right=Ast.Expression.Access{receiver=Optional.empty, name='expr2'}}" classname="plc.project.ParserExpressionTests" time="0.001"/>
  <testcase name="[2] Binary Equality, [IDENTIFIER=expr1@0, OPERATOR===@6, IDENTIFIER=expr2@9], Ast.Expression.Binary{operator='==', left=Ast.Expression.Access{receiver=Optional.empty, name='expr1'}, right=Ast.Expression.Access{receiver=Optional.empty, name='expr2'}}" classname="plc.project.ParserExpressionTests" time="0.001"/>
  <testcase name="[3] Binary Addition, [IDENTIFIER=expr1@0, OPERATOR=+@6, IDENTIFIER=expr2@8], Ast.Expression.Binary{operator='+', left=Ast.Expression.Access{receiver=Optional.empty, name='expr1'}, right=Ast.Expression.Access{receiver=Optional.empty, name='expr2'}}" classname="plc.project.ParserExpressionTests" time="0.001"/>
  <testcase name="[4] Binary Multiplication, [IDENTIFIER=expr1@0, OPERATOR=*@6, IDENTIFIER=expr2@8], Ast.Expression.Binary{operator='*', left=Ast.Expression.Access{receiver=Optional.empty, name='expr1'}, right=Ast.Expression.Access{receiver=Optional.empty, name='expr2'}}" classname="plc.project.ParserExpressionTests" time="0.001"/>
  <testcase name="[1] Function Expression, [IDENTIFIER=name@0, OPERATOR=(@4, OPERATOR=)@5, OPERATOR=;@6], Ast.Statement.Expression{expression=Ast.Expression.Function{receiver=Optional.empty, name='name', arguments=[]}}" classname="plc.project.ParserExpressionTests" time="0.004"/>
  <system-out><![CDATA[]]></system-out>
  <system-err><![CDATA[]]></system-err>
</testsuite>
